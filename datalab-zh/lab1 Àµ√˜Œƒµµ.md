# 实验1 数据实验说明文档

> **练习完成方式：独立完成**
>
> **实验0有点磕磕碰碰？领略什么是真正的痛苦吧**
>
> **请一定咬牙坚持，实在无从下手也请按照翻阅教材-翻看课件-同学切磋-老师请教的顺序进行**
>
> **是时候翻烂书本了**
>
> **尽早开始，尽量在课程开始三周内提交**
>
> **保证是自己动手做出来的**
>
> **==请不要直接搜索或者讨论答案本身==，鼓励交流讨论非答案内容**
>
> **实验源码：仔细阅读此文档，编写程序完成指定功能，并运行测试通过，将修改过的源文件上传 [Gitee](https://gitee.com/)** **（供自己备份）和 学习通作业（供老师检查）**
>
> **实验文档撰写：要求使用 markdown格式书写，放在源码文件夹下面，推荐使用 [Typora](https://typora.io/)**

[TOC]

## 概述

​	在这个实验中，你将修改bits.c，文件包含了一系列的编程”谜题“，每个谜题的函数体为空，你需要完成它以实现特定的数学功能，例如“绝对值”。虽然许多难题都是人为设置的，但当你通过这些难题时你将会对位级操作有更清晰的认识。

### 实验目标

- 熟悉整数和浮点数的位级操作。
- 按照函数注释的要求完成指定的函数功能。

### 提供的资料

- 开始代码包

  starter code [link](https://cnchen2000.oss-cn-shanghai.aliyuncs.com/csapp/datalab-zh.zip) (直接按住ctrl点击打开此超链接)下载后解压，请**先按照lab0说明文档后面所附的实验环境配置安装好环境**，通过mobaXterm连接WSL，把解压文件夹拖动到WSL中，用VS Code打开项目文件夹。

  需要编写代码的源文件包括：

​				**bits.c**			

- 此说明文档 

## 需提交的材料清单

### 1 修改后的bits.c 

​	bits.c文件包含有13个编程”谜题“的函数框架，你的任务是完善每个函数，并且要求在完成整数谜题时只能使用”直线“（straightline）代码，你只能使用有限的算术和逻辑运算符来完成，具体来说，你只能使用下面8个运算符：`! ˜ & ˆ | + << >>`   有的函数要求可能更严格，而且你**不能使用任何长度超过8位的常量**。在完成浮点数谜题时，你可以使用控制和任意的运算符。更多细节规定和编码风格要求请查看bits.c的注释。

### 2 实验说明文档

​	做实验的同时别忘了写文档记录，记录实验过程（关于函数功能，实现过程，测试情况，bug调试）并写下实验==心得体会==（关于实验心里活动、碰到的难点、解决后的收获、能力成长或其他）。

## 实验内容

### 实验说明

​	下表按照难度顺序列出了所有的函数“谜题”，包括了函数名、描述、分值、最多被允许的运算符数量（Max ops）。更多细节请查看 bits.c 文件中的函数注释。你也可以查看 tests.c 中的测试函数，这些函数用于测试你的函数的正确性。

| 函数名              | 描述                                                         | 分值 | Max ops |
| ------------------- | ------------------------------------------------------------ | ---- | ------- |
| bitXor(x, y)        | 只使用 ~ 和 & 实现 x^y                                       | 1    | 14      |
| tmin()              | 返回补码表示的最小值                                         | 1    | 4       |
| isTmax(x)           | 如果 x 是补码表示的最大值，则返回 1                          | 1    | 10      |
| allOddBits(x)       | 如果所有奇数位都是 1，则返回 1                               | 2    | 12      |
| negate(x)           | 返回 -x                                                      | 2    | 5       |
| isAsciDigit(x)      | 如果 0x30 <= x <= 0x39 （'0' 和 '9'的 ASCII值）则返回 1      | 3    | 15      |
| conditional         | 实现条件运算符 x ? y : z                                     | 3    | 16      |
| isLessOrEqual(x, y) | 如果 x <= y 返回 1, 否则返回 0                               | 3    | 24      |
| logicalNeg(x)       | 实现逻辑非 ! 运算符, 使用除 ! 之外的其他允许使用的运算符     | 4    | 12      |
| howManyBits(x)      | 返回补码表示 x 所需要的最少位数（复杂题，选做）              | 4    | 90      |
| floatScale2(uf)     | 为浮点型参数 f 返回与表达式 2*f 等价的位级表示               | 4    | 30      |
| floatFloat2Int(uf)  | 为浮点型参数 f 返回与表达式 (int)f 等价的位级表示 （复杂题，选做） | 4    | 30      |
| floatPower2(x)      | 为任意的 32位 int x 返回与表达式 2.0^x (2.0 的 x 次幂) 等价的位级表示 | 4    | 30      |



### 背景知识   

1. ####  布尔类型 

​	绝大多数高级编程语言都支持显式地表示真和假这两个值，它们的类型称为布尔类型。在C语言中，添加头文件 #include <stdbool.h> 即可直接使用布尔类型（bool），值要么为真（true）要么为假（false），注意字母全小写。计算机硬件能存储的是1和0，这里布尔值 true 存储为 1，false 存储为 0。更一般地，值为0的被认为是 false，只要值不是0都被认为是true。	

### 任务步骤

#### 任务1 按开始代码中的注释要求实现各函数功能	

​	对于后面3个与浮点数相关的函数“谜题”，你将实现一些常见的单精度浮点数操作。在实现时，可以使用控制结构（条件，循环），可以使用 int 和 unsigned 数据类型，以及任意长度的无符号和有符号整型常量，不能使用数组和结构，最主要的，你不能使用浮点类型，浮点操作，或浮点常量。浮点操作数将以 unsigned 类型传递给函数，浮点值也将以 unsigned 类型返回，你的代码应该通过位操作来实现指定的浮点操作。

##### ishow 和 fshow

​	开始代码中的程序ishow 和 fshow 可以帮助你理解整数和浮点数的结构表示。通过输入 make 命令构建它们：

```c
unix> make
```

​	编译后你可以使用 ishow 或 fshow 来查看任意形式表示的整数值或浮点值，使用十进制或者十六进制数作为参数：

```
unix> ./ishow 0x27
Hex = 0x00000027,	Signed = 39,	Unsigned = 39

unix> ./ishow 27
Hex = 0x0000001b,	Signed = 27,	Unsigned = 27

unix> ./fshow 0x15213243
Floating point value 3.255334057e-26
Bit Representation 0x15213243, sign = 0, exponent = 0x2a, fraction = 0x213243
Normalized.  +1.2593463659 X 2^(-85)

linux> ./fshow 15213243
Floating point value 2.131829405e-38
Bit Representation 0x00e822bb, sign = 0, exponent = 0x01, fraction = 0x6822bb
Normalized.  +1.8135598898 X 2^(-126)
```

##### 分值	

​	你的分值将包括三个部分，满分67分：

- 36分 正确
- 26分 性能
- 5分 编码风格

​    正确分（correctness）：函数“谜题”按照难度分值分布为1分到4分，总分是36。btest 程序将用于评估你写的函数，具体细节见任务二。通过测试得分，不通过则不得分。

​    性能分（performance）：虽然目前的实验主要还是关注代码的正确性，我们还是希望你的代码简单明了。其中有些“谜题”可以暴力求解，但希望你能更聪明地解决。因此，每个函数都设置了被允许的最多运算符数量，这个值设置的很宽松，除非你的代码极其低效，否则你都会获得2分的性能分。

​	风格分（style）：最后有5分的主观分，用于评估你的编码风格和注释。你的代码应该干净直接，你的注释应该言简意赅。

#### 任务2 测试你的代码

##### 使用到的工具

​	开始代码里面有3个工具 btest， dlc， driver.pl可以用于测试你的代码。

- btest：用于检查你在bits.c中所写的函数的正确性的测试程序，要编译和运行 btest，终端输入：


```shell
unix> make btest
unix> ./btest
```

​	注意每次修改bits.c文件后，都需要重新 make 来编译 btest。当从一个平台移动到另一个平台时，如果你想删除旧版本的 btest，生成一个新的，可以使用命令：

```shell
unix> make clean   
```

你会发现一次测试一个函数会更有帮助，使用 -f 标志来指示 btest 只测试一个函数：

```shell
unix> ./btest -f bitXor
```

​	你还可以使用-1 -2 -3 标志指定函数参数：

```
unix> ./btest -f bitXor -1 4 -2 5
```

​	对于每个函数，btest 会运行百万个测试用例来检测你的代码的正确性。包括一些常见的边界例子，0， Tmin，denorm-norm 边界，inf等，当 btest 检测出某个函数的错误时，会显示没通过哪个测试，不正确的结果，和期望的结果，然后终止这个函数的测试。btest 不会检查你代码是否符合函数规定的要求，可以使用 dlc 来检查。
- dlc：一个修改过的 ANSI C 编译器，用于检查你的编码风格，使用方法是：

```shell
unix> ./dlc bits.c
```

​	dlc程序将安静地运行直到检测到问题，例如非法运算符，太多的运算符，整数函数中的非直线代码。

​	想要dlc打印每个函数使用的运算符数量，添加 -e  ：

```
unix> ./dlc -e bits.c
```

 	键入 ./dlc -help 查看命令选项列表。

​	driver.pl：这是一个驱动程序，使用 btest 和 dlc 来计算你的代码的正确性和性能，没有参数：

```
unix> ./driver.pl
```

​	请在最后使用  driver.pl 评估你的解答。

##### 注意事项

- ​	不要在 bits.c 文件中包含 <stdio.h> 头文件，它将会和 dlc 不兼容并导致一些非直观的错误信息。在 bits.c 中你依然可以使用 printf 来调试，虽然 gcc 可能会给警告，但是你可以忽略这个警告。编程时一般不要忽略gcc 的警告。


- ​	dlc 程序强制更严格的 C 声明：任何声明语句必须在任何非声明语句之前 (C90)。下面的代码将会报错：


```
int foo(int x)
{
int a = x;
a *= 3; /* Statement that is not a declaration */
int b = a; /* ERROR: Declaration not allowed here */
}
```



#### 任务3 评估

- ./btest:

![image-20210907195758970](https://cnchen2000.oss-cn-shanghai.aliyuncs.com/img/image-20210907195758970.png)



- ./dlc:

![image-20210907181615869](https://cnchen2000.oss-cn-shanghai.aliyuncs.com/img/image-20210907181615869.png)

./driver.pl

![image-20210907195700627](https://cnchen2000.oss-cn-shanghai.aliyuncs.com/img/image-20210907195700627.png)

​	加油实现吧，坚持就是胜利！

### Tips

- 测试是关键，使用 btest 检查你的函数是否功能正确。
- x ^ x = 0 可以用于检测某个 x 的位模式是否是你期望的
- -x = ~x + 1



------

