## ![img](https://cnchen2000.oss-cn-shanghai.aliyuncs.com/img/logo.png)      大数据专业Linux系统编程 实验报告📝

| 专业                 | 学号         | 姓名         |
| :------------------- | ------------ | ------------ |
| 数据科学与大数据技术 | 2104240713   | 江成         |
| **课程名称**         | **实验名称** | **完成日期** |
| Linux系统编程        | Lab1 datalab | 2023.09.29   |



- [      大数据专业Linux系统编程 实验报告📝](#------大数据专业linux系统编程-实验报告)
  - [一 实验目标](#一-实验目标)
  - [二 实验要求](#二-实验要求)
  - [四 实验内容](#四-实验内容)
    - [修改 bits.c 结构](#修改-bitsc-结构)
      - [bitXor](#bitxor)
      - [tmin](#tmin)
      - [isTmax](#istmax)
      - [allOddBits](#alloddbits)
      - [negate](#negate)
      - [isAsciiDigit](#isasciidigit)
      - [conditional](#conditional)
      - [isLessOrEqual](#islessorequal)
      - [logicalNeg](#logicalneg)
      - [howManyBits](#howmanybits)
      - [floatScale2](#floatscale2)
      - [floatFloat2Int](#floatfloat2int)
      - [floatPower2](#floatpower2)
    - [评估](#评估)
  - [五 实验心得](#五-实验心得)
  - [注：](#注)



### 一 实验目标

- 熟悉整数和浮点数的位级操作。
- 按照函数注释的要求完成指定的函数功能。

### 二 实验要求

- 个人独立完成，积极动手编程；
- 鼓励与同学交流，但不能抄袭源码；
- 能完成实验说明文档的各个步骤并撰写此实验报告；
- 能演示实验过程并阐述功能的主要代码模块。
- 实验报告请突出自己的**想法**、**做法**、**心得体会**；

- ## 三、实验环境

- 操作系统：Linux
- 编程工具：Visual Studio Code
- 文档编辑器：Typora
- 网站：https://blog.csdn.net/wcywcywcywcywcy/article/details/120008789



### 四 实验内容

#### 修改 bits.c 结构

- **任务描述**：bits.c文件包含有13个编程”谜题“的函数框架，你的任务是完善每个函数，并且要求在完成整数谜题时只能使用”直线“（straightline）代码，你只能使用有限的算术和逻辑运算符来完成，具体来说，你只能使用下面8个运算符：`! ˜ & ˆ | + << >>`   有的函数要求可能更严格，而且你**不能使用任何长度超过8位的常量**。在完成浮点数谜题时，你可以使用控制和任意的运算符。更多细节规定和编码风格要求请查看bits.c的注释。

##### bitXor

- **任务描述**：

```shell
/*
 * bitXor - 只使用 ~ 和 & 实现 x^y
 *   例如: bitXor(4, 5) = 1
 *   合法运算符: ~ &
 *   最多运算符数量: 14
 *   分值: 1
 */
/*
```

- **实现方法**：

  ![Screen-Shot-2023-09-21-at-15.19.29.png](https://s1.imagehub.cc/images/2023/09/21/Screen-Shot-2023-09-21-at-15.19.29.png)
  
  ```c
  int bitXor(int x, int y)
  {
      // 德摩根律    x^y=
      // 1.(x|y)&(~x|~y)
      // 2.~(~x&~y)&~(x&y)
      // 3.(x&~y)|(~x&y)
      return ~(~x & ~y) & ~(x & y);
  }
  ```

##### tmin
- **任务描述**：

```shell
/*
 * tmin - 返回补码表示的最小值
 *   合法运算符: ! ~ & ^ | + << >>
 *   最多运算符数量: 4
 *   分值: 1
 */
```

- **实现方法**：

  补码表示的最小值为100 .... 0(32位)，即将1左移31位
  
  ```c
  int tmin(void)
  {
      // 补码表示的最小值为100 .... 0(32位)，即将1左移31位
      return 1 << 31;
  }
  ```

##### isTmax

- **任务描述**：

```shell
/*
 * isTmax - 如果 x 是补码表示的最大值，则返回 1
 *   合法运算符: ! ~ & ^ | +
 *   最多运算符数量: 10
 *   分值: 1
 */
```

- **实现方法**：

  补码表示的最大值为0111 .... 1(32位)，Tmax = 0x7FFFFFFF, Tmax+1 = Tmin = 0x80000000。~(Tmax+1) = Tmax，只需判断 ~(x+1) 与 x 是否相等即可得出结论。但是，题目要求不能用等于号，于是利用 x^x = 0 的性质进行判断，即 return !~(x+1)^x。
  但是 -1，即 0xFFFFFFFF，进行上述操作后也满足要求，因为 0xFFFFFFFF + 1后发生了溢出，结果成了0x00000000，也满足!~(x+1)^x = 1。故要对 -1 进行单独处理。

  ```c
  int isTmax(int x)
  { // v1
      // 补码表示的最大值为0111 .... 1(32位)，Tmax = 0x7FFFFFFF, Tmax+1 = Tmin = 0x80000000。
      // ~(Tmax+1) = Tmax，只需判断 ~(x+1) 与 x 是否相等即可得出结论。但是，题目要求不能用等于号，于是利用 x^x = 0 的性质进行判断，即 return !~(x+1)^x。
      // 但是 -1，即 0xFFFFFFFF，进行上述操作后也满足要求，因为 0xFFFFFFFF + 1后发生了溢出，结果成了0x00000000，也满足!~(x+1)^x = 1。故要对 -1 进行单独处理。
      return !(~(x + 1) ^ x) & (!!(x + 1));
      // v2
      // return !((~x) ^ (1<<31));(但是<<在此题不能使用，dlc:bits.c:158:isTmax: Illegal operator (<<))
  }
  ```

##### allOddBits

- **任务描述**：

```shell
/*
 * allOddBits - 如果所有奇数位都是 1，则返回 1
 *   位的编号是从 0 (最低有效位 LSB) to 31 (最高有效位 MSB)
 *   例如： allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1
 *   合法运算符: ! ~ & ^ | + << >>
 *   最多运算符数量: 12
 *   分值: 2
 */
```

- **实现方法**：

  先创建一个32位的掩码，其中所有奇数位都设置为1，然后将输入值与这个掩码进行比较。如果输入值的奇数位都为1，返回1，否则返回0。这样可以检查是否所有奇数位都是1。

  ```c
  int allOddBits(int x)
  {
      int a = 0xA;
      int aa = a | (a << 4);
      int aaa = aa | (aa << 8);
      int aaaa = aaa | (aaa << 16);
      return !((x & aaaa) ^ aaaa);
  }
  ```

##### negate

- **任务描述**：

```shell
/*
 * negate - 返回 -x
 *   例如: negate(1) = -1.
 *   合法运算符: ! ~ & ^ | + << >>
 *   最多运算符数量: 5
 *   分值: 2
 */
```

- **实现方法**：

  -x = ~x + 1

  ```c
  int negate(int x)
  {
      return ~x + 1;
  }
  ```

##### isAsciiDigit

- **任务描述**：

```shell
/*
 * isAsciiDigit - 如果 0x30 <= x <= 0x39 （'0' 和 '9'的 ASCII值）则返回 1
 *   例如: isAsciiDigit(0x35) = 1.
 *            isAsciiDigit(0x3a) = 0.
 *            isAsciiDigit(0x05) = 0.
 *   合法运算符: ! ~ & ^ | + << >>
 *   最多运算符数量: 15
 *   分值: 3
 */
```

- **实现方法**：

  若要满足 0x30 <= x <= 0x39，需要满足如下条件：
  1.高26位全为0
  2.第5，6位为1
  3.低四位为 0000 - 1001

  ```c
  int isAsciiDigit(int x)
  {
      // 若要满足 0x30 <= x <= 0x39，需要满足如下条件：
      // 1.高26位全为0
      // int cond1 = !(x >> 6);
      // 2.第5，6位为1
      // int cond2 = !((x >> 4) ^ 0b11);
      // 3.低四位为 0000 - 1001
      // int cond3 = !!(((x & 0xF) - 0xA) >> 31);
      return !(x >> 6) & (!(0b11 ^ (x >> 4))) & ((((x & 0xF) + (~0xA) + 1) >> 31) & 1);
  }
  ```

##### conditional

- **任务描述**：

```shell
/*
 * conditional - 实现条件运算符 x ? y : z
 *   例如: conditional(2,4,5) = 4
 *   合法运算符: ! ~ & ^ | + << >>
 *   最多运算符数量: 16
 *   分值: 3
 */
```

- **实现方法**：

  x为真，即非0，则返回y；反之返回z，可先对x进行规格化，即!!x，若x为0，则!!x为0；反之则为1，而后对其进行先左移31位，而后右移31的操作，使其变为全1，或全0。

  ```c
  int conditional(int x, int y, int z)
  {
      // x为真，即非0，则返回y；反之返回z
      // 可先对x进行规格化，即!!x，若x为0，则!!x为0；反之则为1
      // 而后对其进行先左移31位，而后右移31的操作，使其变为全1，或全0
      int op = ((!!x) << 31) >> 31;
      // 至此，op与~op一个为全0，一个为全1；将其与y，z进行按位与(&)操作，即可得到结果
      // (op & y) | ((~op) & z)
      return (op & y) | ((~op) & z);
  }
  ```

##### isLessOrEqual

- **任务描述**：

```shell
/*
 * isLessOrEqual - 如果 x <= y  返回 1, 否则返回 0
 *   例如: isLessOrEqual(4,5) = 1.
 *   合法运算符: ! ~ & ^ | + << >>
 *   最多运算符数量: 24
 *   分值: 3
 */
```

- **实现方法**：

  若要判断 x <= y 则需要考虑如下几种情况：
  1.x == y，则返回1
  2.x为正，y为负，则返回0
  3.x为负，y为正，则返回1
  4.x，y同号，则执行x-y，然后判断结果的符号位是否为1，若为1，则返回1；反之，返回0

  ```c
  int isLessOrEqual(int x, int y)
  {
      // 若要判断 x <= y 则需要考虑如下几种情况：
      // 1.x == y，则返回1
      int cond1 = !(x ^ y);
      // 取x，y的符号位并规格化
      int signX = (x >> 31) & 1;
      int signY = (y >> 31) & 1;
      // 2.x为正，y为负，则返回0
      int cond2 = (!signX) & signY;
      // 3.x为负，y为正，则返回1
      int cond3 = signX & (!signY);
      // 4.x，y同号，则执行x-y，然后判断结果的符号位是否为1，若为1，则返回1；反之，返回0
      int cond4 = ((x + ~y + 1) >> 31) & 1;
      return cond1 | ((!cond2) & (cond3 | cond4));
  }
  ```

##### logicalNeg

- **任务描述**：

```shell
/*
 * logicalNeg - 实现逻辑非 ! 运算符, 使用除 ! 之外的其他允许使用的运算符
 *   例如: logicalNeg(3) = 0, logicalNeg(0) = 1
 *   合法运算符: ~ & ^ | + << >>
 *   最多运算符数量: 12
 *   分值: 4
 */
```

- **实现方法**：

  x  = 0111;-x = 1001;若 x 非0，x与-x按位或并将结果右移31位，则得到了全1；若 x 为0，按照上述操作则得到全0，按照上述操作得到结果后加1，则为!x的结果

  ```c
  int logicalNeg(int x)
  {
      // x  = 0111;
      // -x = 1001;
      // 若 x 非0，x与-x按位或并将结果右移31位，则得到了全1；
      // 若 x 为0，按照上述操作则得到全0
      // 按照上述操作得到结果后加1，则为!x的结果
      return (((~x + 1) | x) >> 31) + 1;
  }
  ```
  

##### howManyBits

- **任务描述**：

```shell
/* howManyBits - 返回补码表示 x 所需要的最少位数（复杂题，选做）
 *  例如: howManyBits(12) = 5
 *            howManyBits(298) = 10
 *            howManyBits(-5) = 4
 *            howManyBits(0)  = 1
 *            howManyBits(-1) = 1
 *            howManyBits(0x80000000) = 32
 *  合法运算符: ! ~ & ^ | + << >>
 *  最多运算符数量: 90
 *  分值: 4
*/
```

- **实现方法**：

  ```c
  int howManyBits(int x)
  {
      // 检查x是否为0，将结果存储在isZero中
      int isZero = !x;
  
      // 检查x的符号位（最高位），将结果存储在flag中
      int flag = x >> 31;
  
      // 创建掩码mask
      int mask = ((!!x) << 31) >> 31;
  
      // 将x的符号位翻转，如果x是正数，保持不变；如果是负数，变为其绝对值
      x = (flag & (~x)) | ((~flag) & x);
  
      // 初始化用于存储各位信息的变量
      int bit_16, bit_8, bit_4, bit_2, bit_1, bit_0;
  
      // 检查x的高16位中是否有1，如果有，bit_16为1，否则为0
      bit_16 = (!((!!(x >> 16)) ^ (0x1))) << 4;
      x >>= bit_16; // 将x向右移动bit_16位
  
      bit_8 = (!((!!(x >> 8)) ^ (0x1))) << 3;
      x >>= bit_8;
  
      bit_4 = (!((!!(x >> 4)) ^ (0x1))) << 2;
      x >>= bit_4;
  
      bit_2 = (!((!!(x >> 2)) ^ (0x1))) << 1;
      x >>= bit_2;
  
      bit_1 = (!((!!(x >> 1)) ^ (0x1)));
      x >>= bit_1;
  
      // 最低位bit_0即为x的最低位的值
      bit_0 = x;
      // 计算各位的总和，加上1是因为bit_0也要计数
      int res = bit_0 + bit_1 + bit_2 + bit_4 + bit_8 + bit_16 + 1;
  
      // 将 isZero与 mask 做或运算，如果x为0，结果仍为0；如果x不为0，结果会根据掩码的情况进行修改
      return isZero | (mask & res);
  }
  ```

1. `isZero` 变量用于检查输入 `x` 是否为零。如果 `x` 为零，`isZero` 将为 1，否则为 0。

2. `flag` 变量用于检查 `x` 的符号位（最高位），如果 `x` 为正数，`flag` 为 0，如果 `x` 为负数，`flag` 为 -1。

3. `mask` 变量用于根据 `x` 是否为零来生成一个掩码。如果 `x` 不为零，`mask` 将全部位都设置为1，否则为0。

4. 接下来，对 `x` 的符号位进行处理，如果 `x` 为负数，将其变为其绝对值。

5. 使用 `bit_16`、`bit_8`、`bit_4`、`bit_2`、`bit_1` 和 `bit_0` 变量来检查 `x` 的不同位上是否有1。这些变量通过位移和位操作来计算。

6. 最后，将这些位的值相加，并加上1，得到结果 `res`，表示补码表示 `x` 所需的最少位数。

7. 最后一步，将 `isZero` 与 `mask` 做或运算，确保如果 `x` 为零，结果仍然为零。这是因为补码表示零只需要一个位。

这个函数利用类似二分的思想计算一个数的补码表示所需的最少位数。

##### floatScale2

- **任务描述**：

```shell
/*
 * floatScale2 - 为浮点型参数 f 返回与表达式 2*f 等价的位级表示
 *   参数和返回值都以 unsigned int 传递, 但是它们将被解释成位级表示的单精度浮点值
 *   当参数是 NaN, 返回参数
 *   合法运算符: 任何 int/unsigned 支持的运算符包括 || && 还有 if, while
 *   最多运算符数量: 30
 *   分值: 4
 */
```

- **实现方法**：

  ```c
  // 提取符号位（最高位），存储在s中
      unsigned s = (uf >> 31) & (0x1);
  
      // 提取指数部分，存储在expr中
      unsigned expr = (uf >> 23) & (0xFF);
  
      // 提取尾数部分，存储在frac中
      unsigned frac = uf & 0x7FFFFF;
  
      // 如果指数和尾数均为0，表示浮点数为零，无需操作，直接返回
      if (expr == 0 && frac == 0)
          return uf;
  
      // 如果指数为全1（0xFF），表示浮点数为无穷大或NaN，无需操作，直接返回
      if (expr == 0xFF)
          return uf;
  
      // 如果指数为0，表示浮点数为非规范化数或零，将尾数左移一位
      if (expr == 0)
      {
          frac <<= 1;
          return (s << 31) | frac; // 将符号位和左移后的尾数合并后返回
      }
  
      // 对规范化数，将指数加1，实现乘以2的操作
      expr++;
  
      // 将符号位、新指数、和尾数合并后返回
      return (s << 31) | (expr << 23) | (frac);
  ```

1. 首先，通过位运算提取了浮点数的三个部分：符号位（最高位）、指数部分（接下来的8位）、尾数部分（剩余的23位）。

2. 接下来，检查一些特殊情况：
   - 如果指数和尾数都为0，表示浮点数为零，这时无需进行任何操作，直接返回原始值 `uf`。
   - 如果指数为全1（0xFF），表示浮点数为无穷大或NaN，同样无需操作，直接返回原始值 `uf`。
   - 如果指数为0，表示浮点数为非规范化数或零，代码将尾数左移一位，实现乘以2的操作，并将符号位和左移后的尾数合并后返回。

3. 对于规范化数，代码将指数加1，实现乘以2的操作，并将符号位、新指数和尾数合并后返回。

##### floatFloat2Int

- **任务描述**：

```shell
/*
 * floatFloat2Int - 为浮点型参数 f 返回与表达式 (int)f 等价的位级表示 （复杂题，选做）
 *   参数和返回值都以 unsigned int 传递, 但是它们将被解释成位级表示的单精度浮点值
 *   超出表示范围的(包括 NaN 和 infinity) 应该返回 0x80000000u
 *   合法运算符: 任何 int/unsigned 支持的运算符包括 || && 还有 if, while
 *   最多运算符数量: 30
 *   分值: 4
 */
```

- **实现方法**：

  ```c
  int floatFloat2Int(unsigned uf)
  {
      // 提取符号位（最高位），存储在s中
      unsigned s = (uf >> 31) & (0x1);
  
      // 提取指数部分，存储在expr中
      unsigned expr = (uf >> 23) & (0xFF);
  
      // 提取尾数部分，存储在frac中
      unsigned frac = uf & 0x7FFFFF;
  
      // 如果指数和尾数均为0，表示浮点数为零，返回整数0
      if (expr == 0 && frac == 0)
          return 0;
  
      // 如果指数为0，表示浮点数为非规范化数或零，返回整数0
      if (expr == 0)
      {
          return 0;
      }
  
      // 计算指数的实际值，减去127是因为IEEE 754中的偏移
      int E = expr - 127;
  
      // 将尾数的隐含的整数部分的1位加上，得到带有整数部分的尾数
      frac = frac | (1 << 23);
  
      // 如果指数超过了整数表示范围（32位），返回最大整数值
      if (E > 31)
          return 1 << 31;
      // 如果指数小于0，返回整数0
      else if (E < 0)
          return 0;
  
      // 根据指数将带有整数部分的尾数左移或右移，以获得最终整数值
      if (E >= 23)
          frac <<= (E - 23);
      else
          frac >>= (23 - E);
  
      // 如果符号位为1，表示负数，返回带有符号位的补码表示
      if (s)
          return ~frac + 1;
  
      // 否则，返回带有整数值的无符号整数
      return frac;
  }
  ```

1. 首先，提取浮点数的三个部分：符号位（最高位）、指数部分（接下来的8位）、尾数部分（剩余的23位）。
2. 如果指数和尾数均为0，表示浮点数为零，直接返回整数0。
3. 如果指数为0，表示浮点数为非规范化数或零，同样返回整数0。
4. 为了得到带有整数部分的尾数，将尾数的隐含的整数部分的1位加上。
5. 如果指数超过了整数表示范围（32位），返回最大整数值。
6. 如果指数小于0，返回整数0。
7. 根据指数将带有整数部分的尾数左移或右移，以获得最终整数值。
8. 如果符号位为1，表示负数，返回带有符号位的补码表示。
10. 否则，返回带有整数值的无符号整数。

##### floatPower2

- **任务描述**：

```shell
/*
 * floatPower2 - 为任意的 32位 int x 返回与表达式 2.0^x (2.0 的 x 次幂) 等价的位级表示
 *   返回的 unsigned 值应该有和单精度浮点值 2.0^x 一模一样的位级表示
 *   如果结果太小无法表示成 denorm 时，则返回 0
 *   如果太大，则返回 +INF.
 *
 *   合法运算符: 任何 int/unsigned 支持的运算符包括 || && 还有 if, while
 *   最多运算符数量: 30
 *   分值: 4
 */
```

- **实现方法**：

  ```c
  unsigned floatPower2(int x)
  {
      // 如果x小于-149，表示指数太小，无法用单精度浮点数表示，返回0
      if (x < -149)
      {
          return 0;
      }
      // 如果x介于-149和-126之间，需要进行规范化，左移尾数部分
      else if (x < -126)
      {
          // 计算需要左移的位数，其中23是尾数的位数，x+126是偏移
          int shift = 23 + (x + 126);
  
          // 左移得到结果，即2的x次方对应的浮点数表示
          return 1 << shift;
      }
      // 如果x介于-126和127之间，直接计算2的x次方对应的浮点数表示
      else if (x <= 127)
      {
          // 计算指数部分，x+127是偏移
          int expr = x + 127;
  
          // 构建结果，左移得到2的x次方对应的浮点数表示
          return expr << 23;
      }
      // 如果x大于等于127，表示指数太大，无法用单精度浮点数表示，返回最大正无穷
      else
      {
          return (0xFF) << 23; // 0xFF表示所有位都为1，即正无穷
      }
  }
  ```

首先检查 `x` 的值：
- 如果 `x` 小于 -149，表示指数太小，无法用单精度浮点数表示，因此返回0。
- 如果 `x` 介于 -149 和 -126 之间，需要进行规范化，将尾数部分左移以表示小的浮点数值。计算需要左移的位数，其中23是尾数的位数，`x + 126` 是偏移。然后左移以得到结果，即 `2.0^x` 对应的浮点数表示。
- 如果 `x` 介于 -126 和 127 之间，直接计算 `2.0^x` 对应的浮点数表示。计算指数部分，`x + 127` 是偏移，然后构建结果，左移以得到结果。
- 如果 `x` 大于等于 127，表示指数太大，无法用单精度浮点数表示，因此返回最大正无穷。

#### 评估

- ./btest:

​	![Screen-Shot-2023-09-29-at-15.46.28.png](https://s1.imagehub.cc/images/2023/09/29/Screen-Shot-2023-09-29-at-15.46.28.png)


- ./dlc:

  ![Screen-Shot-2023-09-29-at-15.48.41.png](https://s1.imagehub.cc/images/2023/09/29/Screen-Shot-2023-09-29-at-15.48.41.png)

![Screen-Shot-2023-09-29-at-15.48.30.png](https://s1.imagehub.cc/images/2023/09/29/Screen-Shot-2023-09-29-at-15.48.30.png)

- ./driver.pl

![Screen-Shot-2023-09-29-at-15.47.51.png](https://s1.imagehub.cc/images/2023/09/29/Screen-Shot-2023-09-29-at-15.47.51.png)

- 实现过程

下面是此任务时间线：

![Screen-Shot-2023-09-29-at-15.53.22.png](https://s1.imagehub.cc/images/2023/09/29/Screen-Shot-2023-09-29-at-15.53.22.png)
![Screen-Shot-2023-09-29-at-15.53.34.png](https://s1.imagehub.cc/images/2023/09/29/Screen-Shot-2023-09-29-at-15.53.34.png)

### 五 实验心得

本次实验可谓充满挑战，经历了相当的困难，但也获得了深刻的收获和感悟，其中的许多教训与《深入理解计算机系统》这本书中的观点不谋而合。

**挑战与问题**

实验从开始到结束历时一周多，期间遇到了各种问题，有一个突出的问题是超时问题。当我的代码无法通过测试并不断报超时错误时，我陷入了一片迷茫。我试图多次修改代码，但问题似乎无法迎刃而解。这种困境引发了我对编程和问题解决的思考，我开始思考如何找到突破口，克服这个看似无法逾越的障碍。

![Screen-Shot-2023-09-29-at-15.55.51.png](https://s1.imagehub.cc/images/2023/09/29/Screen-Shot-2023-09-29-at-15.55.51.png)

**解决之道**

最终，通过上网搜索和与同学的讨论，我发现了解决超时问题的方法——修改Makefile中的编译优化参数。虽然这个方法可能看起来有些“巧取豪夺”，但它在实际情况中却解决了问题，帮助我成功完成了实验。这个经历教会了我在遇到困难时，应该积极寻找解决方案，不断尝试不同的方法，而不是轻易放弃。

![Screen-Shot-2023-09-29-at-15.56.41.png](https://s1.imagehub.cc/images/2023/09/29/Screen-Shot-2023-09-29-at-15.56.41.png)

**实验收获**

本次实验深入理解了位操作和浮点数表示的原理，正如书中所强调的，计算机系统的基本组成部分是理解计算机科学的关键。我不仅学到了如何使用合法运算符来实现各种功能，还领悟到了计算机底层的工作方式。书中关于“存储器层次结构”的讲解也帮助我更好地理解了内存和缓存的重要性。

**感悟与反思**

通过这次实验，我更加明白了在解决问题和克服困难时的重要原则：坚持不懈和积极求解。即使面临看似无法逾越的困难，只要保持耐心和勇气，总能找到解决问题的方法。这正是书中强调的“计算机系统是如何工作的”的核心思想。

这次实验的经历也让我对计算机科学的广度和深度有了更深刻的认识，明白了自己在这个领域的不足之处，同时也激励我更加努力学习和提高。书中对“程序性能优化”的论述也提醒我，在编程过程中要注意代码的效率，不断改进和优化，以提高程序的性能。

总的来说，尽管这次实验充满了挑战，但通过不懈努力和坚持，我成功地完成了它。这个过程不仅让我学到了知识，还培养了我的解决问题的能力，为我的计算机科学之路打下了坚实的基础。正如书中所说，“深入理解计算机系统”是一个漫长而充满挑战的过程，而这次实验正是我在这一过程中的一小步，但它对我来说却是一大步。

### 注：

本次实验代码可在如下网址找到：

https://github.com/ChengZ2003/LinuxLab/tree/main/datalab-zh
